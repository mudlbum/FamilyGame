<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sketchy Signals - P2P Drawing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #162447;
            --border-color: #1f4068;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0e0;
            --accent-color: #e43f5a;
            --accent-hover: #b8324f;
        }

        .light-mode {
            --bg-primary: #f0f4f8;
            --bg-secondary: #ffffff;
            --border-color: #d1d9e6;
            --text-primary: #1a1a2e;
            --text-secondary: #5a5a8e;
            --accent-color: #ff4d6d;
            --accent-hover: #e03c5a;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }

        .panel {
            background-color: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .game-button {
            background-color: var(--accent-color);
            color: white;
            transition: background-color 0.3s;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
        }

        .game-button:hover {
            background-color: var(--accent-hover);
        }

        .game-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #drawing-canvas {
            cursor: crosshair;
        }

        .tool-btn.active {
            background-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--accent-color);
        }

        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #162447;
        }

        select,
        input[type="text"],
        input[type="range"] {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
        }
    </style>
</head>

<body class="flex flex-col h-screen items-center p-2 sm:p-4">

    <div id="game-container" class="w-full max-w-screen-2xl mx-auto flex-grow flex flex-col lg:flex-row gap-4 hidden">
        <div class="panel w-full lg:w-1/5 p-4 flex flex-col flex-shrink-0">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-center">Players</h2>
                <button id="theme-toggle-btn" class="p-2 rounded-full bg-gray-700/50 text-xl">‚òÄÔ∏è</button>
            </div>
            <div id="player-list" class="space-y-3 overflow-y-auto flex-grow"></div>
            <div class="mt-4">
                <div id="voice-controls" class="space-y-2">
                    <button id="join-voice-btn" class="game-button w-full py-2">Join Voice Chat</button>
                    <div id="call-controls" class="hidden flex gap-2">
                        <button id="mute-btn" class="game-button w-full py-2">Mute</button>
                        <button id="end-call-btn"
                            class="game-button w-full py-2 bg-gray-600 hover:bg-gray-700">Leave</button>
                    </div>
                </div>
                <div id="music-controls" class="mt-4 space-y-2">
                    <label class="text-sm">Music Volume</label>
                    <div class="flex items-center gap-2">
                        <button id="mute-music-btn">üîä</button>
                        <input type="range" id="music-volume-slider" min="0" max="1" step="0.01" value="0.2"
                            class="w-full">
                    </div>
                </div>
                <div id="host-controls" class="mt-4 hidden">
                    <div class="space-y-2 mb-2">
                        <div class="flex items-center justify-between">
                            <span class="text-sm font-semibold">AI API Status</span>
                            <div class="flex items-center gap-2">
                                <span id="api-status-dot"
                                    class="inline-block w-2.5 h-2.5 rounded-full bg-gray-500"></span>
                                <span id="api-status-text" class="text-xs text-gray-300">Not checked</span>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <label class="block text-sm font-semibold mb-1">Share Link:</label>
                        <div class="flex">
                            <input type="text" id="share-link" class="w-full p-2 rounded-l-md text-xs" readonly>
                            <button id="copy-link-btn" class="game-button px-3 rounded-r-md text-sm">Copy</button>
                        </div>
                    </div>
                    <button id="start-game-btn" class="game-button w-full py-2 px-4 rounded-lg mt-4">Start Game</button>
                </div>
            </div>
        </div>

        <div class="flex-grow flex flex-col gap-4 min-h-[300px] sm:min-h-[400px] lg:h-auto">
            <div class="panel p-4 text-center">
                <div id="game-status" class="text-xl font-semibold h-8">Waiting to start...</div>
                <div id="word-display" class="text-3xl font-bold mt-1 h-12"></div>
                <div id="timer-display" class="text-lg font-semibold h-8 text-amber-400"></div>
                <div id="ai-image-display" class="mt-2 hidden max-h-48 mx-auto">
                    <img id="ai-image" class="max-h-48 rounded-lg mx-auto" />
                </div>
            </div>
            <div id="ai-ascii-display" class="panel p-3 hidden flex-grow overflow-auto">
                 <pre id="ai-ascii" class="whitespace-pre-wrap leading-4 text-xs m-auto"></pre>
            </div>
            <div id="canvas-container" class="panel p-2 flex-grow relative">
                <canvas id="drawing-canvas"></canvas>
                <div id="artist-tools"
                    class="absolute top-2 right-2 flex flex-col gap-2 bg-gray-800/50 p-2 rounded-lg hidden">
                    <input type="color" id="color-picker" value="#FFFFFF" class="w-10 h-10 rounded-md">
                    <input type="range" id="brush-size" min="1" max="20" value="3" class="w-20">
                    <button id="eraser-btn" class="tool-btn p-2 rounded-md">Eraser</button>
                    <button id="clear-btn" class="p-2 rounded-md bg-red-500/80">Clear</button>
                </div>
            </div>
        </div>

        <div class="panel w-full lg:w-1/4 p-4 flex flex-col flex-shrink-0">
            <h2 class="text-2xl font-bold text-center mb-4">Chat</h2>
            <div class="flex-grow flex flex-col">
                <div id="chat-messages" class="flex-grow overflow-y-auto mb-4 pr-2 min-h-[150px]"></div>
                <div class="flex gap-2">
                    <input type="text" id="guess-input" placeholder="Type your guess..." class="flex-grow p-2">
                    <button id="send-guess-btn" class="game-button px-4 py-2 rounded-lg">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="setup-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center z-50">
        <div class="modal-content p-8 rounded-lg text-center max-w-md">
            <h1 class="text-3xl font-bold mb-4" data-translate-key="title">Sketchy Signals</h1>
            <div class="space-y-4">
                <input type="text" id="player-name-input" placeholder="Enter your name" class="p-2 w-full text-center"
                    data-translate-key="namePlaceholder">
                <select id="language-select" class="p-2 w-full">
                    <option value="en">English</option>
                    <option value="es">Espa√±ol</option>
                    <option value="fr">Fran√ßais</option>
                    <option value="ko">ÌïúÍµ≠Ïñ¥</option>
                    <option value="zh">‰∏≠Êñá (Mandarin)</option>
                    <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä (Hindi)</option>
                </select>
                <select id="gamemode-select" class="p-2 w-full">
                    <option value="word" data-translate-key="modeWord">Classic: Draw a Word</option>
                    <option value="ai_image" data-translate-key="modeAI">AI Mode: Guess the ASCII Art</option>
                </select>
                <button id="join-game-btn" class="game-button w-full py-2 px-4 rounded-lg"
                    data-translate-key="joinButton">Join Game</button>
            </div>
        </div>
    </div>

    <div id="audio-container" class="hidden"></div>

    <script type="module">
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const setupModal = document.getElementById('setup-modal');
        const playerNameInput = document.getElementById('player-name-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const shareLinkInput = document.getElementById('share-link');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const hostControls = document.getElementById('host-controls');
        const playerListDiv = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameStatus = document.getElementById('game-status');
        const wordDisplay = document.getElementById('word-display');
        const timerDisplay = document.getElementById('timer-display');
        const aiImageDisplay = document.getElementById('ai-image-display');
        const aiImage = document.getElementById('ai-image');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const artistTools = document.getElementById('artist-tools');
        const colorPicker = document.getElementById('color-picker');
        const brushSizeSlider = document.getElementById('brush-size');
        const eraserBtn = document.getElementById('eraser-btn');
        const clearBtn = document.getElementById('clear-btn');
        const chatMessages = document.getElementById('chat-messages');
        const guessInput = document.getElementById('guess-input');
        const sendGuessBtn = document.getElementById('send-guess-btn');
        const languageSelect = document.getElementById('language-select');
        const gamemodeSelect = document.getElementById('gamemode-select');
        const joinVoiceBtn = document.getElementById('join-voice-btn');
        const callControls = document.getElementById('call-controls');
        const muteBtn = document.getElementById('mute-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const audioContainer = document.getElementById('audio-container');
        const musicVolumeSlider = document.getElementById('music-volume-slider');
        const muteMusicBtn = document.getElementById('mute-music-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const aiAsciiDisplay = document.getElementById('ai-ascii-display');
        const aiAscii = document.getElementById('ai-ascii');
        const apiStatusDot = document.getElementById('api-status-dot');
        const apiStatusText = document.getElementById('api-status-text');

        // --- Game State & Config ---
        let peer, myPeerId, roomId, isHost, connections = {};
        let playerName = '';
        let gameState = createInitialGameState();
        let drawing = false;
        let lastX = 0, lastY = 0;
        let currentBrushSize = 3, currentColor, isErasing = false;
        let localStream, isMuted = false;
        let musicPlayer;
        let myLanguage = 'en';
        let roundTimerId = null;
        let roundTimerIntervalId = null;

        const DRAWING_ASPECT_RATIO = 16 / 9;
        let drawable = { x: 0, y: 0, width: 0, height: 0 };

        const translations = {
            en: { title: "Sketchy Signals", namePlaceholder: "Enter your name", joinButton: "Join Game", createButton: "Create Game", modeWord: "Classic: Draw a Word", modeAI: "AI Mode: Guess the ASCII Art" },
            es: { title: "Se√±ales Esquivas", namePlaceholder: "Ingresa tu nombre", joinButton: "Unirse al Juego", createButton: "Crear Juego", modeWord: "Cl√°sico: Dibuja una Palabra", modeAI: "Modo IA: Adivina el Arte ASCII" },
            fr: { title: "Signaux Vagues", namePlaceholder: "Entrez votre nom", joinButton: "Rejoindre le jeu", createButton: "Cr√©er le jeu", modeWord: "Classique : Dessiner un mot", modeAI: "Mode IA : Devinez l'art ASCII" },
            ko: { title: "Ïä§ÏºÄÏπò ÏãúÍ∑∏ÎÑê", namePlaceholder: "Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî", joinButton: "Í≤åÏûÑ Ï∞∏Í∞Ä", createButton: "Í≤åÏûÑ ÎßåÎì§Í∏∞", modeWord: "ÌÅ¥ÎûòÏãù: Îã®Ïñ¥ Í∑∏Î¶¨Í∏∞", modeAI: "AI Î™®Îìú: ASCII ÏïÑÌä∏ Ï∂îÏ∏°" },
            zh: { title: "Ê®°Á≥ä‰ø°Âè∑", namePlaceholder: "ËæìÂÖ•‰Ω†ÁöÑÂêçÂ≠ó", joinButton: "Âä†ÂÖ•Ê∏∏Êàè", createButton: "ÂàõÂª∫Ê∏∏Êàè", modeWord: "ÁªèÂÖ∏Ê®°ÂºèÔºöÁîª‰∏Ä‰∏™ËØç", modeAI: "AIÊ®°ÂºèÔºöÁåúASCIIËâ∫ÊúØ" },
            hi: { title: "‡§ß‡•Å‡§Ç‡§ß‡§≤‡•á ‡§∏‡§Ç‡§ï‡•á‡§§", namePlaceholder: "‡§Ö‡§™‡§®‡§æ ‡§®‡§æ‡§Æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç", joinButton: "‡§ñ‡•á‡§≤ ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã‡§Ç", createButton: "‡§ñ‡•á‡§≤ ‡§¨‡§®‡§æ‡§è‡§Ç", modeWord: "‡§ï‡•ç‡§≤‡§æ‡§∏‡§ø‡§ï: ‡§è‡§ï ‡§∂‡§¨‡•ç‡§¶ ‡§¨‡§®‡§æ‡§è‡§Ç", modeAI: "‡§è‡§Ü‡§à ‡§Æ‡•ã‡§°: ASCII ‡§ï‡§≤‡§æ ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§® ‡§≤‡§ó‡§æ‡§è‡§Ç" },
        };
        const wordLists = {
            en: ["house", "dog", "sun", "car", "tree"], es: ["casa", "perro", "sol", "coche", "√°rbol"], fr: ["maison", "chien", "soleil", "voiture", "arbre"], ko: ["Ïßë", "Í∞ú", "Ìï¥", "Ï∞®", "ÎÇòÎ¨¥"], zh: ["ÊàøÂ≠ê", "Áãó", "Â§™Èò≥", "Ê±ΩËΩ¶", "Ê†ë"], hi: ["‡§ò‡§∞", "‡§ï‡•Å‡§§‡•ç‡§§‡§æ", "‡§∏‡•Ç‡§∞‡§ú", "‡§ó‡§æ‡§°‡§º‡•Ä", "‡§™‡•á‡§°‡§º"],
        };

        const correctSound = () => new Tone.Synth().toDestination().triggerAttackRelease("C5", "8n");
        const turnStartSound = () => new Tone.Synth().toDestination().triggerAttackRelease("G4", "8n");

        function maskWord(word) {
            if (!word) return '';
            return Array.from(word).map(ch => /\p{L}|\p{Number}/u.test(ch) ? '_' : ch).join(' ');
        }

        function initializePeer(id) {
            myPeerId = id;
            peer = new Peer(myPeerId, { host: '0.peerjs.com', port: 443, secure: true, debug: 1 });
            peer.on('open', () => {
                if (isHost) {
                    updateShareLink();
                } else {
                    connectToHost();
                }
            });
            peer.on('connection', setupConnection);
            peer.on('call', handleIncomingCall);
        }

        function connectToHost() {
            const conn = peer.connect(roomId, { metadata: { name: playerName, lang: myLanguage }, reliable: true });
            setupConnection(conn);
        }

        function setupConnection(conn) {
            connections[conn.peer] = conn;
            conn.on('open', () => {
                if (isHost) {
                    if (Object.keys(gameState.players).length < 10) {
                        gameState.players[conn.peer] = { name: conn.metadata.name, score: 0, isMuted: false, lang: conn.metadata.lang };
                        updateUI();
                        broadcast({ type: 'gameState', state: gameState });
                    }
                }
                if (localStream) {
                    peer.call(conn.peer, localStream);
                }
            });
            conn.on('data', handleData);
            conn.on('close', () => {
                delete connections[conn.peer];
                const audioEl = document.getElementById(`audio-${conn.peer}`);
                if (audioEl) audioEl.remove();

                if (isHost) {
                    const departingPlayerName = gameState.players[conn.peer]?.name || 'A player';
                    const wasArtist = gameState.currentArtistPeerId === conn.peer;

                    delete gameState.players[conn.peer];

                    if (wasArtist && gameState.isRoundActive) {
                        const message = `${departingPlayerName} (the artist) left. Skipping to the next round.`;
                        addChatMessage('System', message, false);
                        broadcast({ type: 'chat', senderName: 'System', message: message, isCorrect: false });
                        setTimeout(startNextRound, 2000);
                    } else {
                        updateUI();
                        broadcast({ type: 'gameState', state: gameState });
                    }
                }
            });
        }

        function handleData(data) {
            if (isHost) {
                switch (data.type) {
                    case 'guess':
                        handleGuess(data.peerId, data.guess);
                        break;
                    case 'draw':
                        broadcast(data, data.peerId);
                        let receivedColorForHost = data.color;
                        const hostTheme = document.body.classList.contains('light-mode') ? 'light' : 'dark';
                        if (data.senderTheme && data.senderTheme !== hostTheme) {
                            if (receivedColorForHost === '#FFFFFF') {
                                receivedColorForHost = '#000000';
                            } else if (receivedColorForHost === '#000000') {
                                receivedColorForHost = '#FFFFFF';
                            }
                        }
                        drawLine(data.x0, data.y0, data.x1, data.y1, receivedColorForHost, data.size, false);
                        break;
                    case 'clearCanvas':
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        broadcast(data, data.peerId);
                        break;
                }
            } else {
                switch (data.type) {
                    case 'gameState':
                        const wasRoundActive = gameState.isRoundActive;
                        gameState = data.state;
                        updateUI();
                        if (!wasRoundActive && gameState.isRoundActive) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        break;
                    case 'draw':
                        let receivedColor = data.color;
                        const myTheme = document.body.classList.contains('light-mode') ? 'light' : 'dark';
                        if (data.senderTheme && data.senderTheme !== myTheme) {
                            if (receivedColor === '#FFFFFF') {
                                receivedColor = '#000000';
                            } else if (receivedColor === '#000000') {
                                receivedColor = '#FFFFFF';
                            }
                        }
                        drawLine(data.x0, data.y0, data.x1, data.y1, receivedColor, data.size, false);
                        break;
                    case 'clearCanvas':
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        break;
                    case 'playSound':
                        if (data.sound === 'correct') correctSound();
                        if (data.sound === 'turnStart') turnStartSound();
                        break;
                    case 'chat':
                        addChatMessage(data.senderName, data.message, data.isCorrect);
                        break;
                    case 'timerUpdate':
                        updateTimerDisplay(data.timeLeft);
                        break;
                }
            }
        }


        function broadcast(data, excludePeer = null) {
            Object.values(connections).forEach(conn => {
                if (conn.peer !== excludePeer) {
                    conn.send(data);
                }
            });
        }

        function createInitialGameState() {
            return {
                players: {},
                currentRound: 0,
                totalRounds: 10,
                currentArtistPeerId: null,
                secretWordSet: {},
                isRoundActive: false,
                language: 'en',
                gameMode: 'word',
                wordLists: null,
                roundScore: 10,
                usedWordIndices: [],
                aiAscii: null,
            };
        }

        function handleGuess(peerId, guess) {
            const guesserName = gameState.players[peerId].name;
            const correctWords = Object.values(gameState.secretWordSet).map(w => w.toLowerCase());

            if (gameState.isRoundActive && correctWords.includes(guess.toLowerCase())) {
                if (roundTimerId) clearTimeout(roundTimerId);
                if (roundTimerIntervalId) clearInterval(roundTimerIntervalId);

                gameState.isRoundActive = false;

                const guesserScore = gameState.roundScore;
                const artistScore = Math.ceil(guesserScore / 2);

                if (gameState.gameMode === 'ai_image') {
                    gameState.players[peerId].score += 15;
                } else {
                    gameState.players[peerId].score += guesserScore;
                    if (gameState.players[gameState.currentArtistPeerId]) {
                        gameState.players[gameState.currentArtistPeerId].score += artistScore;
                    }
                }

                const correctMessage = `${guesserName} guessed the word! (+${guesserScore})`;
                addChatMessage('System', correctMessage, true);
                broadcast({ type: 'chat', senderName: 'System', message: correctMessage, isCorrect: true });

                correctSound();
                broadcast({ type: 'playSound', sound: 'correct' });

                updateUI();
                broadcast({ type: 'gameState', state: gameState });

                setTimeout(startNextRound, 3000);
            } else {
                if (gameState.isRoundActive && gameState.roundScore > 1) {
                    gameState.roundScore--;
                }
                addChatMessage(guesserName, guess, false);
                broadcast({ type: 'chat', senderName: guesserName, message: guess, isCorrect: false });
            }
        }

        async function startNextRound() {
            if (isHost) {
                if (roundTimerId) clearTimeout(roundTimerId);
                if (roundTimerIntervalId) clearInterval(roundTimerIntervalId);

                gameState.totalRounds = Object.keys(gameState.players).length * 2;
                gameState.currentRound++;
                gameState.roundScore = 10;
                gameState.aiAscii = null;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                broadcast({ type: 'clearCanvas' });

                if (gameState.currentRound > gameState.totalRounds || Object.keys(gameState.players).length < 2) {
                    gameState.isRoundActive = false;
                    updateUI();
                    broadcast({ type: 'gameState', state: gameState });
                    startGameBtn.classList.remove('hidden');
                    return;
                }

                const playerIds = Object.keys(gameState.players);
                gameState.currentArtistPeerId = playerIds[(gameState.currentRound - 1) % playerIds.length];

                if (!gameState.wordLists) {
                    gameState.wordLists = await getWordsFromGemini(50);
                }

                const totalWordsAvailable = gameState.wordLists.en.length;
                if (gameState.usedWordIndices.length >= totalWordsAvailable) {
                    const message = "All words used. Fetching a new list...";
                    addChatMessage('System', message, false);
                    broadcast({ type: 'chat', senderName: 'System', message: message, isCorrect: false });
                    gameState.wordLists = await getWordsFromGemini(50);
                    gameState.usedWordIndices = [];
                }

                let wordIndex;
                do {
                    wordIndex = Math.floor(Math.random() * gameState.wordLists.en.length);
                } while (gameState.usedWordIndices.includes(wordIndex));

                gameState.usedWordIndices.push(wordIndex);

                gameState.secretWordSet = {};
                for (const lang in gameState.wordLists) {
                    gameState.secretWordSet[lang] = gameState.wordLists[lang][wordIndex];
                }

                if (gameState.gameMode === 'ai_image') {
                    const ascii = await generateAsciiArt(gameState.secretWordSet.en);
                    if (ascii) {
                        gameState.isRoundActive = true;
                        gameState.aiAscii = ascii;
                    } else {
                        gameState.gameMode = 'word';
                        gameState.isRoundActive = true;
                    }
                } else {
                    gameState.isRoundActive = true;
                }

                updateUI();
                broadcast({ type: 'gameState', state: gameState });
                turnStartSound();
                broadcast({ type: 'playSound', sound: 'turnStart' });

                startRoundTimer();
            }
        }

        function startRoundTimer() {
            const roundDuration = 120; // 2 minutes in seconds
            let timeLeft = roundDuration;

            updateTimerDisplay(timeLeft);
            broadcast({ type: 'timerUpdate', timeLeft: timeLeft });

            roundTimerIntervalId = setInterval(() => {
                timeLeft--;
                updateTimerDisplay(timeLeft);
                broadcast({ type: 'timerUpdate', timeLeft: timeLeft });
            }, 1000);

            roundTimerId = setTimeout(() => {
                clearInterval(roundTimerIntervalId);
                if (isHost && gameState.isRoundActive) {
                    gameState.isRoundActive = false;
                    const correctWord = gameState.secretWordSet.en;
                    const message = `Time's up! The word was: ${correctWord}`;
                    
                    addChatMessage('System', message, false);
                    broadcast({ type: 'chat', senderName: 'System', message: message, isCorrect: false });
                    
                    updateUI();
                    broadcast({ type: 'gameState', state: gameState });
                    
                    setTimeout(startNextRound, 3000);
                }
            }, roundDuration * 1000);
        }

        function updateTimerDisplay(seconds) {
            if (seconds < 0) seconds = 0;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            timerDisplay.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }


        async function checkApiKey() {
            const apiKey = "AIzaSyDbIsa8aSaRIlKnXXhMh89qCUUws33B5uo";
            if (!apiKey) return false;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            try {
                const r = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] })
                });
                return r.ok;
            } catch {
                return false;
            }
        }

        function updateApiIndicator(ok) {
            if (!apiStatusDot || !apiStatusText) return;
            apiStatusDot.classList.remove('bg-gray-500', 'bg-red-500', 'bg-green-500', 'bg-yellow-500');
            if (ok === true) {
                apiStatusDot.classList.add('bg-green-500');
                apiStatusText.textContent = 'Connected';
            } else if (ok === false) {
                apiStatusDot.classList.add('bg-red-500');
                apiStatusText.textContent = 'Disconnected';
            } else if (ok === undefined) {
                apiStatusDot.classList.add('bg-yellow-500');
                apiStatusText.textContent = 'Checking...';
            } else {
                apiStatusDot.classList.add('bg-gray-500');
                apiStatusText.textContent = 'Not checked';
            }
        }

        async function attemptApiConnectionWithRetries(maxAttempts = 5, interval = 5000) {
            updateApiIndicator(undefined);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const isConnected = await checkApiKey();
                if (isConnected) {
                    updateApiIndicator(true);
                    return true;
                }

                if (attempt < maxAttempts) {
                    apiStatusText.textContent = `Retrying... (${attempt}/${maxAttempts})`;
                    await new Promise(resolve => setTimeout(resolve, interval));
                }
            }

            updateApiIndicator(false);
            return false;
        }

        async function getWordsFromGemini(count) {
            const apiKey = "AIzaSyDbIsa8aSaRIlKnXXhMh89qCUUws33B5uo";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{
                        text: `Give me a JSON object. The keys are "en", "es", "fr", "ko", "zh", "hi". The value for each key must be an array of ${count} moderately difficult, drawable nouns. The words should come from diverse categories (e.g., objects, animals, concepts, actions, places). Ensure the words at each index are direct translations of each other.`
                    }]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                }
            };

            try {
                const response = await fetch(apiUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error("Gemini API error: " + response.status);

                const result = await response.json();

                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const cleanedText = result.candidates[0].content.parts[0].text.replace(/^```json\s*|```\s*$/g, '');
                    return JSON.parse(cleanedText);
                }

                throw new Error("Unexpected Gemini response format");
            } catch (error) {
                console.error("Error fetching words:", error);
                return wordLists;
            }
        }

        async function generateAsciiArt(prompt) {
            const apiKey = "AIzaSyDbIsa8aSaRIlKnXXhMh89qCUUws33B5uo";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            const fullPrompt = `You are an ASCII art generator. Your task is to create simple, clear, and recognizable ASCII art. The art MUST be a direct visual representation of the subject given below. Do not include any other objects or characters. The art should be small (around 15-25 lines) and use only standard text characters. Do not include any explanatory text, commentary, or code fences like \`\`\`. The output must be only the ASCII art itself. For example, if the subject is "ocean", create art of waves, not a person on a beach.\n\nSubject: ${prompt}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: fullPrompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 400
                        }
                    })
                });
                if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                return text || null;
            } catch (e) {
                console.error('ASCII art generation failed', e);
                return null;
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const { clientWidth, clientHeight } = container;

            if (clientWidth <= 0 || clientHeight <= 0) return;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            if (canvas.width > 0 && canvas.height > 0) {
                tempCtx.drawImage(canvas, 0, 0);
            }

            canvas.width = clientWidth;
            canvas.height = clientHeight;

            let newWidth = clientWidth;
            let newHeight = newWidth / DRAWING_ASPECT_RATIO;
            if (newHeight > clientHeight) {
                newHeight = clientHeight;
                newWidth = newHeight * DRAWING_ASPECT_RATIO;
            }

            drawable = {
                width: newWidth,
                height: newHeight,
                x: (clientWidth - newWidth) / 2,
                y: (clientHeight - newHeight) / 2,
            };

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (tempCanvas.width > 0) {
                ctx.drawImage(tempCanvas, drawable.x, drawable.y, drawable.width, drawable.height);
            }

            ctx.strokeStyle = 'rgba(128, 128, 128, 0.2)';
            ctx.strokeRect(drawable.x, drawable.y, drawable.width, drawable.height);
        }

        function startDrawing(e) {
            if (e.touches && e.touches.length > 1) {
                drawing = false;
                return;
            }

            if (myPeerId !== gameState.currentArtistPeerId || gameState.gameMode === 'ai_image') return;
            e.preventDefault();
            drawing = true;
            const coords = getEventCoords(e);
            [lastX, lastY] = [coords.x, coords.y];
        }

        function stopDrawing() {
            drawing = false;
        }

        function draw(e) {
            if (e.touches && e.touches.length > 1) {
                return;
            }

            if (!drawing || myPeerId !== gameState.currentArtistPeerId || gameState.gameMode === 'ai_image') return;
            e.preventDefault();
            const coords = getEventCoords(e);

            const drawData = {
                type: 'draw',
                peerId: myPeerId,
                x0: lastX / drawable.width, y0: lastY / drawable.height,
                x1: coords.x / drawable.width, y1: coords.y / drawable.height,
                color: isErasing ? getComputedStyle(document.body).getPropertyValue('--bg-secondary') : currentColor,
                size: currentBrushSize,
                senderTheme: document.body.classList.contains('light-mode') ? 'light' : 'dark'
            };

            const localX0 = lastX + drawable.x;
            const localY0 = lastY + drawable.y;
            const localX1 = coords.x + drawable.x;
            const localY1 = coords.y + drawable.y;

            drawLine(localX0, localY0, localX1, localY1, drawData.color, currentBrushSize, true);

            if (isHost) {
                broadcast(drawData, myPeerId);
            } else {
                connections[roomId]?.send(drawData);
            }
            [lastX, lastY] = [coords.x, coords.y];
        }

        function drawLine(x0, y0, x1, y1, color, size, isLocal) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            if (isLocal) {
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
            } else {
                ctx.moveTo(x0 * drawable.width + drawable.x, y0 * drawable.height + drawable.y);
                ctx.lineTo(x1 * drawable.width + drawable.x, y1 * drawable.height + drawable.y);
            }
            ctx.stroke();
        }

        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const event = e.touches ? e.touches[0] : e;
            return {
                x: event.clientX - rect.left - drawable.x,
                y: event.clientY - rect.top - drawable.y
            };
        }

        function updateUI() {
            playerListDiv.innerHTML = '';
            Object.entries(gameState.players).forEach(([peerId, p]) => {
                const div = document.createElement('div');
                div.className = `p-2 rounded-lg flex justify-between items-center ${peerId === gameState.currentArtistPeerId ? 'bg-blue-500/50' : ''}`;
                div.innerHTML = `<span>${p.name} ${peerId === gameState.currentArtistPeerId && gameState.gameMode !== 'ai_image' ? '‚úèÔ∏è' : ''}</span><span class="font-bold">${p.score}</span>`;
                playerListDiv.appendChild(div);
            });

            const isArtist = myPeerId === gameState.currentArtistPeerId;
            artistTools.classList.toggle('hidden', !isArtist || gameState.gameMode === 'ai_image');
            aiImageDisplay.classList.add('hidden'); // This mode is unused for now

            const isAsciiModeActive = gameState.isRoundActive && gameState.gameMode === 'ai_image' && gameState.aiAscii;
            canvasContainer.classList.toggle('hidden', isAsciiModeActive);
            aiAsciiDisplay.classList.toggle('hidden', !isAsciiModeActive);

            if (gameState.isRoundActive) {
                const viewerWord = gameState.secretWordSet?.[myLanguage];

                if (gameState.gameMode === 'ai_image') {
                    gameStatus.textContent = "Guess the prompt!";
                    wordDisplay.textContent = viewerWord ? maskWord(viewerWord) : '';
                    if (gameState.aiAscii) {
                        aiAscii.textContent = gameState.aiAscii;
                    }
                } else {
                    if (isArtist) {
                        gameStatus.textContent = "Your turn to draw!";
                        wordDisplay.textContent = viewerWord || '';
                    } else {
                        const artistName = gameState.players[gameState.currentArtistPeerId]?.name;
                        gameStatus.textContent = artistName ? `Guess what ${artistName} is drawing!` : "Guess what's being drawn!";
                        wordDisplay.textContent = viewerWord ? maskWord(viewerWord) : '';
                    }
                }
            } else {
                timerDisplay.textContent = '';
                if (gameState.currentRound >= gameState.totalRounds && gameState.totalRounds > 0) {
                    const winner = Object.values(gameState.players).sort((a, b) => b.score - a.score)[0];
                    gameStatus.textContent = winner ? `Game Over! Winner: ${winner.name}` : "Game Over!";
                } else {
                    gameStatus.textContent = "Waiting for host to start...";
                }
                wordDisplay.textContent = "";
            }

            startGameBtn.disabled = Object.keys(gameState.players).length < 2;
        }

        function addChatMessage(senderName, message, isCorrect) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('mb-2');
            if (isCorrect) {
                msgDiv.innerHTML = `<p class="font-bold text-green-400">${senderName}: ${message}</p>`;
            } else {
                msgDiv.innerHTML = `<p><span class="font-semibold">${senderName}:</span> ${message}</p>`;
            }
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function setLanguage(lang) {
            myLanguage = lang;
            const key = isHost ? 'createButton' : 'joinButton';
            joinGameBtn.textContent = translations[lang][key];

            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const transKey = el.dataset.translateKey;
                if (translations[lang] && translations[lang][transKey]) {
                    if (el.tagName === 'INPUT') el.placeholder = translations[lang][transKey];
                    else if (el.id !== 'join-game-btn') el.textContent = translations[lang][transKey];
                }
            });
        }


        function updateDefaultDrawingColor() {
            const isLight = document.body.classList.contains('light-mode');
            const newColor = isLight ? '#000000' : '#FFFFFF';

            if (currentColor === '#FFFFFF' || currentColor === '#000000' || !currentColor) {
                currentColor = newColor;
                colorPicker.value = newColor;
            }
        }
        
        function updateShareLink() {
            if (isHost && myPeerId) {
                const url = new URL(window.location.href);
                url.hash = `${myPeerId}_${languageSelect.value}_${gamemodeSelect.value}`;
                shareLinkInput.value = url.href;
            }
        }

        languageSelect.addEventListener('change', (e) => {
            setLanguage(e.target.value);
            if (isHost) updateShareLink();
        });

        joinGameBtn.addEventListener('click', async () => {
            playerName = playerNameInput.value.trim();
            if (!playerName) {
                playerNameInput.focus();
                return;
            }

            await Tone.start();
            
            const hash = window.location.hash.substring(1);
            isHost = !hash;

            if (isHost) {
                myLanguage = languageSelect.value;
                const selectedMode = gamemodeSelect.value;
                myPeerId = `host-${Date.now()}`;
                gameState.language = myLanguage;
                gameState.gameMode = selectedMode;
                gameState.players[myPeerId] = { name: playerName, score: 0, isMuted: false, lang: myLanguage };
                hostControls.classList.remove('hidden');
                
                if (selectedMode === 'ai_image') {
                    attemptApiConnectionWithRetries().then(ok => {
                        if (!ok && isHost) {
                            alert("AI service unavailable. Falling back to Classic mode.");
                            gamemodeSelect.value = 'word';
                            gameState.gameMode = 'word';
                            updateShareLink();
                        }
                    });
                }
            } else {
                myPeerId = `guest-${Date.now()}`;
                const [hashRoomId, hashLang, hashMode] = hash.split('_');
                roomId = hashRoomId;
                myLanguage = languageSelect.value; 
                gameState.language = hashLang;
                gameState.gameMode = hashMode;
            }
            
            setupModal.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            resizeCanvas();

            initializePeer(myPeerId);
            updateUI();
            initializeMusic();
        });

        startGameBtn.addEventListener('click', () => {
            if (isHost) {
                gameState.currentRound = 0;
                Object.values(gameState.players).forEach(p => p.score = 0);
                gameState.usedWordIndices = [];
                gameState.wordLists = null;
                startNextRound();
                startGameBtn.classList.add('hidden');
            }
        });

        copyLinkBtn.addEventListener('click', () => {
            shareLinkInput.select();
            document.execCommand('copy');
        });

        sendGuessBtn.addEventListener('click', () => {
            const guess = guessInput.value.trim();
            if (guess) {
                const isArtist = myPeerId === gameState.currentArtistPeerId;
                if (gameState.gameMode === 'word' && isArtist && Object.keys(gameState.players).length > 1) return;

                const data = { type: 'guess', peerId: myPeerId, guess };
                if (isHost) {
                    handleGuess(myPeerId, guess);
                } else {
                    connections[roomId].send(data);
                }
                guessInput.value = '';
            }
        });
        guessInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendGuessBtn.click();
        });

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchend', stopDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        window.addEventListener('resize', resizeCanvas);

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            isErasing = false;
            eraserBtn.classList.remove('active');
        });
        brushSizeSlider.addEventListener('input', (e) => { currentBrushSize = e.target.value; });
        eraserBtn.addEventListener('click', () => {
            isErasing = !isErasing;
            eraserBtn.classList.toggle('active', isErasing);
        });
        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const clearData = { type: 'clearCanvas', peerId: myPeerId };
            if (isHost) {
                broadcast(clearData, myPeerId);
            } else {
                connections[roomId]?.send(clearData);
            }
        });

        gamemodeSelect.addEventListener('change', async (e) => {
            if (!isHost) return;
            const newMode = e.target.value;
            gameState.gameMode = newMode;
            updateShareLink();

            if (newMode === 'ai_image') {
                const ok = await attemptApiConnectionWithRetries();
                if (!ok) {
                    alert("AI service unavailable. Falling back to Classic.");
                    gamemodeSelect.value = 'word';
                    gameState.gameMode = 'word';
                    updateShareLink();
                }
            } else {
                updateApiIndicator(null);
            }
        });

        joinVoiceBtn.addEventListener('click', async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });
                joinVoiceBtn.classList.add('hidden');
                callControls.classList.remove('hidden');
                Object.values(connections).forEach(conn => peer.call(conn.peer, localStream));
            } catch (err) {
                console.error("Could not get microphone access.", err);
            }
        });

        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (localStream) localStream.getAudioTracks()[0].enabled = !isMuted;
            updateMuteButtonUI();
        });

        endCallBtn.addEventListener('click', () => {
            if (localStream) localStream.getTracks().forEach(track => track.stop());
            localStream = null;
            Object.values(peer.connections).forEach(connArray => {
                connArray.forEach(conn => {
                    if (conn.type === 'media') conn.close();
                });
            });
            joinVoiceBtn.classList.remove('hidden');
            callControls.classList.add('hidden');
        });

        function handleIncomingCall(call) {
            call.answer(localStream);
            call.on('stream', remoteStream => {
                const audioEl = document.createElement('audio');
                audioEl.srcObject = remoteStream;
                audioEl.autoplay = true;
                audioEl.id = `audio-${call.peer}`;
                audioContainer.appendChild(audioEl);
            });
        }

        function updateMuteButtonUI() {
            muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
            muteBtn.classList.toggle('bg-green-500', !isMuted);
            muteBtn.classList.toggle('hover:bg-green-600', !isMuted);
        }

        function initializeMusic() {
            if (musicPlayer) return;
            musicPlayer = new Tone.Player({
                url: "Family Fun Fiesta.mp3",
                loop: true,
                volume: Tone.gainToDb(0.2),
                onload: () => musicPlayer.start()
            }).toDestination();
        }

        musicVolumeSlider.addEventListener('input', (e) => {
            if (musicPlayer) musicPlayer.volume.value = Tone.gainToDb(e.target.value);
        });

        muteMusicBtn.addEventListener('click', () => {
            if (musicPlayer) {
                musicPlayer.mute = !musicPlayer.mute;
                muteMusicBtn.textContent = musicPlayer.mute ? 'üîá' : 'üîä';
            }
        });

        themeToggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            themeToggleBtn.textContent = isLight ? 'üåô' : '‚òÄÔ∏è';
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            updateDefaultDrawingColor();
        });

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'light') {
            document.body.classList.add('light-mode');
            themeToggleBtn.textContent = 'üåô';
        } else {
            themeToggleBtn.textContent = '‚òÄÔ∏è';
        }
        
        const initialHash = window.location.hash.substring(1);
        isHost = !initialHash;
        if (isHost) {
            joinGameBtn.dataset.translateKey = 'createButton';
        } else {
            gamemodeSelect.classList.add('hidden');
            joinGameBtn.dataset.translateKey = 'joinButton';
        }

        updateDefaultDrawingColor();
        setLanguage(languageSelect.value);

    </script>
</body>

</html>